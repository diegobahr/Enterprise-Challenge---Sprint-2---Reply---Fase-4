/*
  SISTEMA DE MONITORAMENTO INDUSTRIAL - VERS√ÉO FINAL
  Hermes Reply Challenge - SIMULA√á√ÉO SEMPRE ATIVA
  
  COMPONENTES:
  ‚úÖ DHT22 (Presente mas ignorado - s√≥ para mostrar no circuito)
  ‚úÖ LDR (Sensor de Luz) - GPIO 36
  ‚úÖ Potenci√¥metro (Vibra√ß√£o) - GPIO 39  
  ‚úÖ LED (Alerta) - GPIO 2
  
  GARANTIA: Temperatura e umidade SEMPRE v√£o variar!
*/

#include <DHT.h>

// ========== DEFINI√á√ïES DOS PINOS ==========
#define DHT_PIN 4       // DHT22 (presente mas n√£o usado)
#define LDR_PIN 36      // LDR  
#define POT_PIN 39      // Potenci√¥metro
#define LED_PIN 2       // LED de alerta

// ========== VARI√ÅVEIS PARA SIMULA√á√ÉO ==========
unsigned long tempo_inicio;
int contador_leituras = 0;

// Par√¢metros da simula√ß√£o
float temp_base = 25.0;
float umid_base = 45.0;

void setup() {
  Serial.begin(115200);
  
  // Configurar pinos
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  
  // Tempo de refer√™ncia
  tempo_inicio = millis();
  
  // Inicializar gerador de n√∫meros aleat√≥rios
  randomSeed(analogRead(0));
  
  delay(2000);
  
  // Cabe√ßalho
  exibir_cabecalho();
  
  // CSV Header
  Serial.println("Timestamp,Temperatura,Umidade,Luminosidade,Vibracao,Status");
}

void loop() {
  // ========== SIMULA√á√ÉO SEMPRE ATIVA ==========
  float temperatura = gerar_temperatura_realistica();
  float umidade = gerar_umidade_realistica();
  
  // ========== SENSORES REAIS ==========
  int luminosidade = analogRead(LDR_PIN);
  int vibracao = analogRead(POT_PIN);
  
  // ========== AN√ÅLISE E CONTROLE ==========
  String status = analisar_sistema(temperatura, vibracao);
  controlar_led_inteligente(status);
  
  // ========== SA√çDA DE DADOS ==========
  enviar_dados_monitoramento(temperatura, umidade, luminosidade, vibracao, status);
  
  // ========== DEBUG OCASIONAL ==========
  debug_periodico();
  
  contador_leituras++;
  delay(2000);
}

// ========== GERA√á√ÉO DE TEMPERATURA REAL√çSTICA ==========
float gerar_temperatura_realistica() {
  float tempo_seg = (millis() - tempo_inicio) / 1000.0;
  
  // M√∫ltiplos padr√µes de varia√ß√£o
  float ciclo_principal = sin(tempo_seg * 0.04) * 4.0;        // Ciclo de ~2.5 min
  float ciclo_secundario = sin(tempo_seg * 0.15) * 1.5;       // Flutua√ß√µes r√°pidas
  float ciclo_lento = sin(tempo_seg * 0.01) * 2.0;            // Varia√ß√£o muito lenta
  
  // Tend√™ncia de aquecimento gradual
  float aquecimento = (tempo_seg / 240.0) * 3.0;              // +3¬∞C em 4 minutos
  
  // Ru√≠do realista
  float ruido = (random(-150, 150) / 100.0);                  // ¬±1.5¬∞C
  
  // Eventos cr√≠ticos espor√°dicos
  float evento_critico = 0;
  if (contador_leituras > 10 && contador_leituras % 28 == 0) {
    evento_critico = random(4, 9);                            // Pico +4 a +9¬∞C
    Serial.println("üö® [SIMULA√á√ÉO] Pico cr√≠tico de temperatura!");
  }
  
  // Mudan√ßas bruscas ocasionais (falhas de equipamento)
  float mudanca_brusca = 0;
  if (contador_leituras > 5 && contador_leituras % 35 == 0) {
    mudanca_brusca = random(-3, 6);                           // Varia√ß√£o s√∫bita
    Serial.println("‚ö° [SIMULA√á√ÉO] Mudan√ßa brusca detectada!");
  }
  
  // Temperatura final
  float temperatura = temp_base + ciclo_principal + ciclo_secundario + 
                     ciclo_lento + aquecimento + ruido + 
                     evento_critico + mudanca_brusca;
  
  // Limites de seguran√ßa
  temperatura = constrain(temperatura, 16.0, 45.0);
  
  return temperatura;
}

// ========== GERA√á√ÉO DE UMIDADE REAL√çSTICA ==========
float gerar_umidade_realistica() {
  float tempo_seg = (millis() - tempo_inicio) / 1000.0;
  
  // Rela√ß√£o inversa com temperatura (f√≠sicamente correta)
  float temperatura_atual = gerar_temperatura_realistica();
  float base_inversa = map(temperatura_atual * 10, 160, 450, 680, 280) / 10.0;
  
  // Varia√ß√µes pr√≥prias da umidade
  float ciclo_umidade = cos(tempo_seg * 0.06) * 8.0;          // Ciclo diferente da temp
  float variacao_climatica = sin(tempo_seg * 0.02) * 5.0;     // Mudan√ßas "clim√°ticas"
  
  // Ru√≠do da umidade
  float ruido_umid = (random(-120, 120) / 100.0);             // ¬±1.2%
  
  // Eventos de umidade (vazamentos, ventila√ß√£o)
  float evento_umidade = 0;
  if (contador_leituras > 8 && contador_leituras % 32 == 0) {
    evento_umidade = random(-8, 15);                          // Mudan√ßa s√∫bita
    Serial.println("üíß [SIMULA√á√ÉO] Evento de umidade (vazamento/ventila√ß√£o)!");
  }
  
  // Umidade final
  float umidade = base_inversa + ciclo_umidade + variacao_climatica + 
                 ruido_umid + evento_umidade;
  
  // Limites f√≠sicos
  umidade = constrain(umidade, 20.0, 85.0);
  
  return umidade;
}

// ========== AN√ÅLISE INTELIGENTE DO SISTEMA ==========
String analisar_sistema(float temp, int vibr) {
  bool temp_alerta = (temp > 32.0);      // Mais restritivo
  bool temp_atencao = (temp > 29.0);     // Mais sens√≠vel
  bool vibr_alerta = (vibr > 3200);      // Ajustado
  bool vibr_atencao = (vibr > 2600);     // Mais sens√≠vel
  
  // L√≥gica combinada
  if (temp_alerta || vibr_alerta) {
    return "ALERTA";
  } else if (temp_atencao || vibr_atencao) {
    return "ATENCAO";  
  } else {
    return "NORMAL";
  }
}

// ========== CONTROLE INTELIGENTE DO LED ==========
void controlar_led_inteligente(String status) {
  if (status == "ALERTA") {
    // Pisca rapidamente (emerg√™ncia)
    piscar_led_emergencia();
  } else if (status == "ATENCAO") {
    // Pisca lentamente (aten√ß√£o)
    piscar_led_atencao();
  } else {
    // Apagado (normal)
    digitalWrite(LED_PIN, LOW);
  }
}

void piscar_led_emergencia() {
  // 4 piscadas r√°pidas
  for(int i = 0; i < 4; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    delay(100);
  }
}

void piscar_led_atencao() {
  // 2 piscadas lentas
  for(int i = 0; i < 2; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(250);
    digitalWrite(LED_PIN, LOW);
    delay(250);
  }
}

// ========== SA√çDA FORMATADA DE DADOS ==========
void enviar_dados_monitoramento(float temp, float umid, int luz, int vibr, String status) {
  Serial.print(millis());
  Serial.print(",");
  Serial.print(temp, 1);
  Serial.print(",");  
  Serial.print(umid, 1);
  Serial.print(",");
  Serial.print(luz);
  Serial.print(",");
  Serial.print(vibr);
  Serial.print(",");
  Serial.println(status);
}

// ========== CABE√áALHO INFORMATIVO ==========
void exibir_cabecalho() {
  Serial.println();
  Serial.println("üè≠ ==========================================");
  Serial.println("    SISTEMA DE MONITORAMENTO INDUSTRIAL");
  Serial.println("         HERMES REPLY CHALLENGE 2025");
  Serial.println("üè≠ ==========================================");
  Serial.println();
  Serial.println("ü§ñ MODO: Simula√ß√£o Ultra-Real√≠stica FOR√áADA");
  Serial.println("   ‚úÖ Temperatura: 16¬∞C - 45¬∞C (vari√°vel)");
  Serial.println("   ‚úÖ Umidade: 20% - 85% (correlacionada)");
  Serial.println("   ‚úÖ Eventos cr√≠ticos autom√°ticos");
  Serial.println("   ‚úÖ Padr√µes industriais realistas");
  Serial.println();
  Serial.println("üìä SENSORES ATIVOS:");
  Serial.println("   üå°Ô∏è  Temperatura (simulada)");
  Serial.println("   üíß Umidade (simulada)");  
  Serial.println("   üí° LDR: Luminosidade (real)");
  Serial.println("   üì≥ POT: Vibra√ß√£o (real)");
  Serial.println("   üî¥ LED: Indicador (real)");
  Serial.println();
  Serial.println("‚öôÔ∏è  ALERTAS CONFIGURADOS:");
  Serial.println("   üü° ATEN√á√ÉO: Temp>29¬∞C OU Vibra√ß√£o>2600");
  Serial.println("   üî¥ ALERTA:  Temp>32¬∞C OU Vibra√ß√£o>3200");
  Serial.println();
  Serial.println("üéÆ CONTROLES INTERATIVOS:");
  Serial.println("   ‚Ä¢ Gire POTENCI√îMETRO = altera vibra√ß√£o");
  Serial.println("   ‚Ä¢ Clique no LDR = altera luminosidade");
  Serial.println("   ‚Ä¢ Temperatura/Umidade = autom√°ticas");
  Serial.println();
  Serial.println("üìà INICIANDO COLETA DE DADOS...");
  Serial.println();
}

// ========== DEBUG PERI√ìDICO ==========
void debug_periodico() {
  if (contador_leituras % 20 == 0 && contador_leituras > 0) {
    float tempo_min = (millis() - tempo_inicio) / 60000.0;
    Serial.print("# [DEBUG] Leituras: ");
    Serial.print(contador_leituras);
    Serial.print(" | Tempo: ");
    Serial.print(tempo_min, 1);
    Serial.println(" min | Sistema: OK");
  }
}
